// Code generated by protoc-gen-go-flipt-sdk. DO NOT EDIT.

package http

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	evaluation "go.flipt.io/flipt/rpc/flipt/evaluation"
	_go "go.flipt.io/flipt/sdk/go"
	grpc "google.golang.org/grpc"
	protojson "google.golang.org/protobuf/encoding/protojson"
	io "io"
	http "net/http"
	url "net/url"
)

type evaluationClient struct {
	client *http.Client
	addr   string
}

func (t evaluationClient) EvaluationServiceClient() evaluation.EvaluationServiceClient {
	return &evaluationServiceClient{client: t.client, addr: t.addr}
}

type evaluationServiceClient struct {
	client *http.Client
	addr   string
}

func (x *evaluationServiceClient) Boolean(ctx context.Context, v *evaluation.EvaluationRequest, _ ...grpc.CallOption) (*evaluation.BooleanEvaluationResponse, error) {
	var body io.Reader
	var values url.Values
	reqData, err := protojson.Marshal(v)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqData)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, x.addr+"/evaluate/v1/boolean", body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output evaluation.BooleanEvaluationResponse
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (x *evaluationServiceClient) Variant(ctx context.Context, v *evaluation.EvaluationRequest, _ ...grpc.CallOption) (*evaluation.VariantEvaluationResponse, error) {
	var body io.Reader
	var values url.Values
	reqData, err := protojson.Marshal(v)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqData)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, x.addr+"/evaluate/v1/variant", body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output evaluation.VariantEvaluationResponse
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (x *evaluationServiceClient) Batch(ctx context.Context, v *evaluation.BatchEvaluationRequest, _ ...grpc.CallOption) (*evaluation.BatchEvaluationResponse, error) {
	var body io.Reader
	var values url.Values
	reqData, err := protojson.Marshal(v)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqData)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, x.addr+"/evaluate/v1/batch", body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output evaluation.BatchEvaluationResponse
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (t evaluationClient) DataServiceClient() evaluation.DataServiceClient {
	return &dataServiceClient{client: t.client, addr: t.addr}
}

type dataServiceClient struct {
	client *http.Client
	addr   string
}

func (x *dataServiceClient) EvaluationSnapshotNamespace(ctx context.Context, v *evaluation.EvaluationNamespaceSnapshotRequest, _ ...grpc.CallOption) (*evaluation.EvaluationNamespaceSnapshot, error) {
	var body io.Reader
	var values url.Values
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, x.addr+fmt.Sprintf("/internal/v1/evaluation/snapshot/namespace/%v", v.Key), body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output evaluation.EvaluationNamespaceSnapshot
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (t Transport) EvaluationClient() _go.EvaluationClient {
	return evaluationClient{client: t.client, addr: t.addr}
}
